// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.0.0.31 by WSRD Tencent.
// Generated from `/usr/local/resin_system.mqq.com/webapps/communication/taf/upload/aarontang/Observer.jce'
// **********************************************************************

#ifndef __OBSERVER_H_
#define __OBSERVER_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;


namespace Observer
{
    enum E_CTRL_TYPE
    {
        E_CTRL_HELLO = 0,
        E_CTRL_HTTP_UPDATE = 1,
    };
    inline string etos(const E_CTRL_TYPE & e)
    {
        switch(e)
        {
            case E_CTRL_HELLO: return "E_CTRL_HELLO";
            case E_CTRL_HTTP_UPDATE: return "E_CTRL_HTTP_UPDATE";
            default: return "";
        }
    }
    inline int stoe(const string & s, E_CTRL_TYPE & e)
    {
        if(s == "E_CTRL_HELLO")  { e=E_CTRL_HELLO; return 0;}
        if(s == "E_CTRL_HTTP_UPDATE")  { e=E_CTRL_HTTP_UPDATE; return 0;}

        return -1;
    }

    struct ControlMsg : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Observer.ControlMsg";
        }
        static string MD5()
        {
            return "5e359591dc4b1bf3861e87f19f32c224";
        }
        ControlMsg()
        :eCtrlType(Observer::E_CTRL_HELLO),sSeq("")
        {
        }
        void resetDefautlt()
        {
            sSeq = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write((taf::Int32)eCtrlType, 0);
            _os.write(sSeq, 1);
            _os.write(vbData, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            taf::Int32 eTemp0 = Observer::E_CTRL_HELLO;
            _is.read(eTemp0, 0, false);
            eCtrlType = (Observer::E_CTRL_TYPE)eTemp0;
            _is.read(sSeq, 1, false);
            _is.read(vbData, 2, false);
        }
    public:
        Observer::E_CTRL_TYPE eCtrlType;
        std::string sSeq;
        vector<taf::Char> vbData;
    };
    inline bool operator==(const ControlMsg&l, const ControlMsg&r)
    {
        return l.eCtrlType == r.eCtrlType && l.sSeq == r.sSeq && l.vbData == r.vbData;
    }
    inline bool operator!=(const ControlMsg&l, const ControlMsg&r)
    {
        return !(l == r);
    }


}

#define Observer_ControlMsg_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.eCtrlType,b.eCtrlType);jce_copy_struct(a.sSeq,b.sSeq);jce_copy_struct(a.vbData,b.vbData);



#endif
